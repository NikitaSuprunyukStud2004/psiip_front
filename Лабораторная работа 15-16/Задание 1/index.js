// 1. В чем заключается суть ООП программирования и его отличие от традиционного процедурного программирования?
// ООП (объектно-ориентированное программирование) основывается на создании объектов, которые объединяют данные и методы.
// Отличие от процедурного программирования:
// - В процедурном программировании код структурирован в виде функций, а данные хранятся отдельно.
// - В ООП код разделен на классы и объекты, что делает его более модульным, гибким и простым для поддержки.

// 2. Что понимается под Классом и Объектом в JS?
// - Класс — это шаблон для создания объектов, который определяет их свойства и методы.
// - Объект — это экземпляр класса, содержащий конкретные данные и методы.

// 3. Пример синтаксиса класса в JS
class Animal1 {
    constructor(name, type) {
        this.name = name;
        this.type = type;
    }

    speak() {
        console.log(`${this.name} издает звук.`);
    }
}

// 4. Как осуществляется создание объектов класса? Пример:
const dog1 = new Animal1('Бобик', 'собака');
dog1.speak(); // Вывод: Бобик издает звук.

// 5. Как происходит обращение к полям и методам внутри класса?
console.log(dog1.name); // Вывод: Бобик
dog1.speak(); // Вывод: Бобик издает звук.

// 6. Как обозначаются в JS публичные, приватные и защищённые поля и методы?
// - Публичные поля и методы — доступны из любой части кода.
// - Приватные поля и методы — обозначаются с помощью символа # перед именем и доступны только внутри класса.
class Person {
    #age; // Приватное поле

    constructor(name, age) {
        this.name = name;
        this.#age = age;
    }

    getAge() {
        return this.#age;
    }
}

const person = new Person('Иван', 30);
console.log(person.getAge()); // Вывод: 30

// 7. Для чего в ООП в JS используется служебное слово static?
// Ключевое слово static используется для определения статических методов и свойств класса, которые принадлежат самому классу, а не его экземплярам.
class MathUtils {
    static add(a, b) {
        return a + b;
    }
}

console.log(MathUtils.add(2, 3)); // Вывод: 5

// 8. Что такое геттеры и сеттеры? Как используются в ООП в JS?
// Геттеры и сеттеры позволяют управлять доступом к свойствам объекта и их изменению.
class Rectangle {
    constructor(width, height) {
        this._width = width;
        this._height = height;
    }

    get area() {
        return this._width * this._height;
    }

    set width(value) {
        if (value > 0) this._width = value;
    }
}

const rect = new Rectangle(10, 5);
console.log(rect.area); // Вывод: 50
rect.width = 20;
console.log(rect.area); // Вывод: 100

// 9. Базовые принципы ООП: инкапсуляция, наследование и полиморфизм
// - Инкапсуляция — скрытие внутренней реализации класса и предоставление интерфейса для взаимодействия.
// - Наследование — механизм, который позволяет классу наследовать свойства и методы другого класса.
// - Полиморфизм — способность объектов разных классов обрабатывать данные через единый интерфейс.

// Пример Инкапсуляции
class Car {
    #engineOn = false;

    startEngine() {
        this.#engineOn = true;
        console.log('Двигатель запущен.');
    }

    stopEngine() {
        this.#engineOn = false;
        console.log('Двигатель остановлен.');
    }
}

const car = new Car();
car.startEngine(); // Вывод: Двигатель запущен.
car.stopEngine();  // Вывод: Двигатель остановлен.

// Пример Наследования
class Animal2 {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} издает звук.`);
    }
}

class Dog extends Animal2 {
    speak() {
        console.log(`${this.name} лает.`);
    }
}

const dog2 = new Dog('Шарик');
dog2.speak(); // Вывод: Шарик лает.

// Пример Полиморфизма
class Shape {
    draw() {
        console.log('Рисуем фигуру.');
    }
}

class Circle extends Shape {
    draw() {
        console.log('Рисуем круг.');
    }
}

class Square extends Shape {
    draw() {
        console.log('Рисуем квадрат.');
    }
}

const shapes = [new Circle(), new Square()];
shapes.forEach(shape => shape.draw());
// Вывод:
// Рисуем круг.
// Рисуем квадрат.  